---
title: "How to Add Annotation Questions"
description: "Define the JSON structure required by the Labellerr SDK to create annotation questions."
icon: circle-question
---

<Card title="Overview" icon="circle-info">
  The Labellerr SDK now expects a single JSON schema for every annotation question. Use the structure below to define questions for object-based and classification workflows.
</Card>

## Required Question Structure

<Card title="Required Fields" icon="asterisk">
Every question you send through the SDK must include the fields below.

| Field | Description | Required |
|---|---|---|
| question_number | Sequential number for the question (1, 2, 3, â€¦). | Yes |
| question_id | Unique identifier (UUID) for the question. | Yes |
| question | The user-facing label or prompt. | Yes |
| option_type | Annotation type (for example `polygon`, `BoundingBox`, `dropdown`, `select`, `radio`, `boolean`, `input`). | Yes |
| required | Set to `true` if the annotator must answer. | Yes |
| options | Array of options. Use an empty array for free-input questions. | Yes |

<Note>
  Generate `question_id` with `str(uuid.uuid4())` to avoid collisions. Reuse IDs only when you intentionally want to update an existing question.
</Note>
</Card>

## Examples

<Card title="Multiple Questions Payload" icon="file-code">
Group questions in a list when creating or updating a template.

```python
from labellerr.client import LabellerrClient
from labellerr.core.projects import create_annotation_guideline
import uuid

questions = [
  {
    "question_number": 1,
    "question": "Draw crop boundary",
    "option_type": "polygon",
    "required": True,
    "question_id": str(uuid.uuid4()),
    "options": [
      { "option_name": "#5F9EA0" }
    ]
  },
  {
    "question_number": 2,
    "question": "Mark vehicle",
    "option_type": "BoundingBox",
    "required": True,
    "question_id": str(uuid.uuid4()),
    "options": [
      { "option_name": "#FFAA00" }
    ]
  },
  {
    "question_number": 3,
    "question": "Overall quality",
    "option_type": "radio",
    "required": True,
    "question_id": str(uuid.uuid4()),
    "options": [
      { "option_name": "Good" },
      { "option_name": "Average" },
      { "option_name": "Poor" }
    ]
  },
  {
    "question_number": 4,
    "question": "Additional remarks",
    "option_type": "input",
    "required": False,
    "question_id": str(uuid.uuid4()),
    "options": []
  }
]

client = LabellerrClient(api_key, api_secret, client_id)
template_id = create_annotation_guideline(
    client=client,
    questions=questions,
    template_name="Demo Template",
    data_type="image"
)
print(f"Annotation template created with ID: {template_id}")
```
</Card>

<Card title="Single Question Payload" icon="play">
Use the same structure even if you only have one question.

```python
from labellerr.core.projects import create_annotation_guideline
import uuid

questions = [
  {
    "question_number": 1,
    "question": "Track object across frames",
    "option_type": "polygon",
    "required": True,
    "question_id": str(uuid.uuid4()),
    "options": [
      { "option_name": "#FE1236" }
    ]
  }
]

template_id = create_annotation_guideline(
    client=client,
    questions=questions,
    template_name="SDK_template",
    data_type="video"
)

print(f"Annotation template created with ID: {template_id}")
```
</Card>

## Optional Metadata

<Note>
  `question_metadata` contains nested attributes for object-based annotations when you need additional dropdowns or toggles per object. Include it only when the UI should capture extra properties.

  ```json
  {
    "question_metadata": [
      {
        "key": "<unique_id>",
        "componentClass": "Select the region of interest",
        "annotation": "select",
        "required": true,
        "options": [
          { "key": "<option_1_id>", "value": "ROI #1" },
          { "key": "<option_2_id>", "value": "ROI #2" }
        ],
        "type": "attribute",
        "searchBar": true
      }
    ]
  }
  ```
</Note>

